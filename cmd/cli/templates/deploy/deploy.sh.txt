#!/bin/bash

# $APPNAME Deployment Script
# This script handles deployment of the application to production

set -e  # Exit on any error

# Configuration
APP_NAME="$APPNAME"
DOCKER_IMAGE="$APP_NAME:latest"
CONTAINER_NAME="$APP_NAME-app"
NETWORK_NAME="$APP_NAME-network"
BACKUP_DIR="/var/backups/$APP_NAME"
LOG_FILE="/var/log/$APP_NAME-deploy.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}" | tee -a "$LOG_FILE"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}" | tee -a "$LOG_FILE"
}

# Check if running as root
check_root() {
    if [[ $EUID -eq 0 ]]; then
        error "This script should not be run as root for security reasons"
        exit 1
    fi
}

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."
    
    # Check if Docker is installed
    if ! command -v docker &> /dev/null; then
        error "Docker is not installed"
        exit 1
    fi
    
    # Check if Docker Compose is installed
    if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
        error "Docker Compose is not installed"
        exit 1
    fi
    
    # Check if .env file exists
    if [[ ! -f ".env" ]]; then
        error ".env file not found"
        exit 1
    fi
    
    log "Prerequisites check passed"
}

# Create backup
create_backup() {
    log "Creating backup..."
    
    # Create backup directory if it doesn't exist
    sudo mkdir -p "$BACKUP_DIR"
    
    # Backup database
    if docker ps | grep -q "$APP_NAME-postgres"; then
        log "Backing up database..."
        docker exec "$APP_NAME-postgres" pg_dump -U postgres "$APP_NAME" > "$BACKUP_DIR/db-backup-$(date +%Y%m%d-%H%M%S).sql"
        
        # Keep only last 10 backups
        sudo find "$BACKUP_DIR" -name "db-backup-*.sql" -type f -printf '%T@ %p\n' | sort -n | head -n -10 | cut -d' ' -f2- | xargs -r rm
    fi
    
    # Backup uploaded files/data
    if [[ -d "storage" ]]; then
        log "Backing up storage files..."
        sudo tar -czf "$BACKUP_DIR/storage-backup-$(date +%Y%m%d-%H%M%S).tar.gz" storage/
        
        # Keep only last 10 storage backups
        sudo find "$BACKUP_DIR" -name "storage-backup-*.tar.gz" -type f -printf '%T@ %p\n' | sort -n | head -n -10 | cut -d' ' -f2- | xargs -r rm
    fi
    
    log "Backup completed"
}

# Build Docker image
build_image() {
    log "Building Docker image..."
    
    # Build the image
    docker build -t "$DOCKER_IMAGE" .
    
    # Tag with timestamp for versioning
    docker tag "$DOCKER_IMAGE" "$APP_NAME:$(date +%Y%m%d-%H%M%S)"
    
    log "Docker image built successfully"
}

# Stop existing containers
stop_containers() {
    log "Stopping existing containers..."
    
    if docker-compose ps | grep -q "Up"; then
        docker-compose down
        log "Containers stopped"
    else
        log "No running containers found"
    fi
}

# Start containers
start_containers() {
    log "Starting containers..."
    
    # Start in production mode
    docker-compose up -d
    
    # Wait for services to be ready
    log "Waiting for services to start..."
    sleep 30
    
    # Check if app is responding
    if curl -f http://localhost:${PORT:-4000}/health > /dev/null 2>&1; then
        log "Application is responding to health checks"
    else
        error "Application is not responding to health checks"
        docker-compose logs app
        exit 1
    fi
    
    log "Containers started successfully"
}

# Run database migrations
run_migrations() {
    log "Running database migrations..."
    
    # Wait for database to be ready
    sleep 10
    
    # Run migrations
    if docker exec "$APP_NAME-app" ./main migrate up > /dev/null 2>&1; then
        log "Database migrations completed"
    else
        warn "Migration command failed or not available"
    fi
}

# Clean up old Docker images
cleanup() {
    log "Cleaning up old Docker images..."
    
    # Remove old images (keep latest 5)
    docker images "$APP_NAME" --format "table {{.ID}}\t{{.Tag}}" | tail -n +2 | sort -k2 -r | tail -n +6 | awk '{print $1}' | xargs -r docker rmi
    
    # Remove dangling images
    docker image prune -f
    
    log "Cleanup completed"
}

# Monitor deployment
monitor_deployment() {
    log "Monitoring deployment..."
    
    # Check container status
    if docker-compose ps | grep -q "Up"; then
        log "All containers are running"
    else
        error "Some containers are not running"
        docker-compose ps
        exit 1
    fi
    
    # Check disk space
    DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [[ $DISK_USAGE -gt 80 ]]; then
        warn "Disk usage is at ${DISK_USAGE}%"
    fi
    
    # Check memory usage
    MEMORY_USAGE=$(free | awk 'NR==2{printf "%.2f", $3*100/$2 }')
    if (( $(echo "$MEMORY_USAGE > 80" | bc -l) )); then
        warn "Memory usage is at ${MEMORY_USAGE}%"
    fi
    
    log "Deployment monitoring completed"
}

# Send notification
send_notification() {
    local status=$1
    local message=$2
    
    if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"[$APP_NAME] Deployment $status: $message\"}" \
            "$SLACK_WEBHOOK_URL" > /dev/null 2>&1 || true
    fi
    
    if [[ -n "$DISCORD_WEBHOOK_URL" ]]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"content\":\"[$APP_NAME] Deployment $status: $message\"}" \
            "$DISCORD_WEBHOOK_URL" > /dev/null 2>&1 || true
    fi
}

# Main deployment process
deploy() {
    log "Starting deployment of $APP_NAME..."
    
    # Send start notification
    send_notification "STARTED" "Deployment process initiated"
    
    # Run deployment steps
    check_prerequisites
    create_backup
    build_image
    stop_containers
    start_containers
    run_migrations
    monitor_deployment
    cleanup
    
    log "Deployment completed successfully!"
    
    # Send success notification
    send_notification "SUCCESS" "Deployment completed successfully"
}

# Rollback function
rollback() {
    log "Rolling back deployment..."
    
    # Get previous image tag
    PREVIOUS_TAG=$(docker images "$APP_NAME" --format "table {{.Tag}}" | grep -E '^[0-9]{8}-[0-9]{6}$' | head -2 | tail -1)
    
    if [[ -n "$PREVIOUS_TAG" ]]; then
        log "Rolling back to image: $APP_NAME:$PREVIOUS_TAG"
        
        # Tag previous image as latest
        docker tag "$APP_NAME:$PREVIOUS_TAG" "$DOCKER_IMAGE"
        
        # Restart containers
        stop_containers
        start_containers
        
        log "Rollback completed"
        send_notification "ROLLBACK" "Rolled back to $PREVIOUS_TAG"
    else
        error "No previous image found for rollback"
        exit 1
    fi
}

# Help function
show_help() {
    echo "Usage: $0 [OPTION]"
    echo ""
    echo "Options:"
    echo "  deploy      Deploy the application (default)"
    echo "  rollback    Rollback to previous version"
    echo "  status      Show current status"
    echo "  logs        Show application logs"
    echo "  help        Show this help message"
    echo ""
    echo "Environment variables:"
    echo "  SLACK_WEBHOOK_URL    Slack webhook for notifications"
    echo "  DISCORD_WEBHOOK_URL  Discord webhook for notifications"
}

# Show status
show_status() {
    echo "=== Docker Containers ==="
    docker-compose ps
    echo ""
    echo "=== System Resources ==="
    echo "Disk Usage: $(df -h / | awk 'NR==2 {print $5}')"
    echo "Memory Usage: $(free -h | awk 'NR==2{printf "%.1f/%.1fGB (%.0f%%)\n", $3/1024/1024, $2/1024/1024, $3*100/$2}')"
    echo ""
    echo "=== Recent Logs ==="
    docker-compose logs --tail=20 app
}

# Show logs
show_logs() {
    docker-compose logs -f
}

# Main script logic
case "${1:-deploy}" in
    deploy)
        check_root
        deploy
        ;;
    rollback)
        check_root
        rollback
        ;;
    status)
        show_status
        ;;
    logs)
        show_logs
        ;;
    help)
        show_help
        ;;
    *)
        echo "Unknown option: $1"
        show_help
        exit 1
        ;;
esac